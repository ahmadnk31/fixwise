{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 14, "column": 0}, "map": {"version":3,"sources":["file:///Users/ss/Downloads/ai-repair-diagnosis-saas-main/lib/supabase/server.ts"],"sourcesContent":["import { createServerClient as createSupabaseServerClient } from \"@supabase/ssr\"\nimport { cookies } from \"next/headers\"\n\nexport async function createServerClient() {\n  const cookieStore = await cookies()\n\n  return createSupabaseServerClient(process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!, {\n    cookies: {\n      getAll() {\n        return cookieStore.getAll()\n      },\n      setAll(cookiesToSet) {\n        try {\n          cookiesToSet.forEach(({ name, value, options }) => cookieStore.set(name, value, options))\n        } catch {\n          // The \"setAll\" method was called from a Server Component.\n          // This can be ignored if you have middleware refreshing\n          // user sessions.\n        }\n      },\n    },\n  })\n}\n\nexport const createClient = createServerClient\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AACA;;;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,iTAAO;IAEjC,OAAO,IAAA,4SAA0B,sUAAoF;QACnH,SAAS;YACP;gBACE,OAAO,YAAY,MAAM;YAC3B;YACA,QAAO,YAAY;gBACjB,IAAI;oBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAAK,YAAY,GAAG,CAAC,MAAM,OAAO;gBAClF,EAAE,OAAM;gBACN,0DAA0D;gBAC1D,wDAAwD;gBACxD,iBAAiB;gBACnB;YACF;QACF;IACF;AACF;AAEO,MAAM,eAAe","debugId":null}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///Users/ss/Downloads/ai-repair-diagnosis-saas-main/components/shop-directory.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const ShopDirectory = registerClientReference(\n    function() { throw new Error(\"Attempted to call ShopDirectory() from the server but ShopDirectory is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/shop-directory.tsx <module evaluation>\",\n    \"ShopDirectory\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;AACO,MAAM,gBAAgB,IAAA,+aAAuB,EAChD;IAAa,MAAM,IAAI,MAAM;AAA0O,GACvQ,+DACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":["file:///Users/ss/Downloads/ai-repair-diagnosis-saas-main/components/shop-directory.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const ShopDirectory = registerClientReference(\n    function() { throw new Error(\"Attempted to call ShopDirectory() from the server but ShopDirectory is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/shop-directory.tsx\",\n    \"ShopDirectory\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;AACO,MAAM,gBAAgB,IAAA,+aAAuB,EAChD;IAAa,MAAM,IAAI,MAAM;AAA0O,GACvQ,2CACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 77, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 85, "column": 0}, "map": {"version":3,"sources":["file:///Users/ss/Downloads/ai-repair-diagnosis-saas-main/lib/utils/shop-matching.ts"],"sourcesContent":["/**\n * Smart shop matching utility\n * Matches shops based on device brand, model, and repair component\n */\n\nexport interface DiagnosisMatch {\n  device_brand?: string\n  device_type?: string\n  repair_component?: string\n  repair_keywords?: string[]\n}\n\n/**\n * Normalize text for matching (lowercase, remove special chars, handle variations)\n */\nfunction normalizeText(text: string): string {\n  return text\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s]/g, '')\n    .trim()\n}\n\n/**\n * Extract brand from device type\n */\nfunction extractBrand(deviceType: string): string {\n  const normalized = normalizeText(deviceType)\n  \n  // Common brand patterns - order matters (more specific first)\n  const brandPatterns: Array<[string, string]> = [\n    ['one plus', 'oneplus'],\n    ['oneplus', 'oneplus'],\n    ['hewlett packard', 'hp'],\n    ['macbook', 'apple'],\n    ['imac', 'apple'],\n    ['ipad', 'apple'],\n    ['ipod', 'apple'],\n    ['iphone', 'apple'],\n    ['galaxy', 'samsung'],\n    ['thinkpad', 'lenovo'],\n    ['alienware', 'dell'],\n    ['rog', 'asus'],\n    ['xperia', 'sony'],\n    ['pixel', 'google'],\n    ['redmi', 'xiaomi'],\n    ['poco', 'xiaomi'],\n    ['surface', 'microsoft'],\n    ['apple', 'apple'],\n    ['samsung', 'samsung'],\n    ['oneplus', 'oneplus'],\n    ['google', 'google'],\n    ['xiaomi', 'xiaomi'],\n    ['oppo', 'oppo'],\n    ['realme', 'realme'],\n    ['vivo', 'vivo'],\n    ['huawei', 'huawei'],\n    ['honor', 'honor'],\n    ['sony', 'sony'],\n    ['lg', 'lg'],\n    ['motorola', 'motorola'],\n    ['moto', 'motorola'],\n    ['nokia', 'nokia'],\n    ['dell', 'dell'],\n    ['hp', 'hp'],\n    ['lenovo', 'lenovo'],\n    ['asus', 'asus'],\n    ['acer', 'acer'],\n    ['msi', 'msi'],\n    ['razer', 'razer'],\n    ['microsoft', 'microsoft'],\n  ]\n  \n  for (const [pattern, brandName] of brandPatterns) {\n    if (normalized.includes(pattern)) {\n      return brandName\n    }\n  }\n  \n  // If no brand found, try to extract first word\n  const words = normalized.split(/\\s+/)\n  return words[0] || ''\n}\n\n/**\n * Get repair component variations\n */\nfunction getRepairComponentVariations(component: string): string[] {\n  const normalized = normalizeText(component)\n  const variations = [normalized]\n  \n  // Common variations mapping\n  const variationMap: Record<string, string[]> = {\n    'screen': ['display', 'lcd', 'oled', 'amoled', 'touchscreen', 'touch screen'],\n    'display': ['screen', 'lcd', 'oled', 'amoled', 'touchscreen'],\n    'battery': ['power', 'charging', 'cell'],\n    'camera': ['lens', 'photo', 'picture'],\n    'charging port': ['usb port', 'charging', 'port', 'connector'],\n    'speaker': ['audio', 'sound'],\n    'microphone': ['mic', 'audio input'],\n    'motherboard': ['mainboard', 'logic board', 'pcb'],\n    'keyboard': ['keys', 'typing'],\n    'trackpad': ['touchpad', 'mouse pad'],\n  }\n  \n  // Add variations\n  for (const [key, values] of Object.entries(variationMap)) {\n    if (normalized.includes(key) || key.includes(normalized)) {\n      variations.push(...values)\n    }\n  }\n  \n  return [...new Set(variations)]\n}\n\n/**\n * Check if shop expertise matches diagnosis\n */\nexport function shopMatchesDiagnosis(\n  shopExpertise: string[],\n  diagnosis: DiagnosisMatch,\n  services?: Array<{ name: string; description?: string | null; type?: string | null }>\n): { matches: boolean; score: number; matchedTerms: string[] } {\n  const matchedTerms: string[] = []\n  let score = 0\n  \n  // Normalize expertise\n  const normalizedExpertise = (shopExpertise || []).map(exp => normalizeText(exp))\n  \n  // Normalize services (only active services)\n  const normalizedServices = (services || [])\n    .filter(s => s.name) // Only services with names\n    .map(s => ({\n      name: normalizeText(s.name),\n      description: s.description ? normalizeText(s.description) : '',\n      type: s.type ? normalizeText(s.type) : '',\n      fullText: `${normalizeText(s.name)} ${s.description ? normalizeText(s.description) : ''} ${s.type ? normalizeText(s.type) : ''}`.trim()\n    }))\n  \n  // If no expertise and no services, no match\n  if (normalizedExpertise.length === 0 && normalizedServices.length === 0) {\n    return { matches: false, score: 0, matchedTerms: [] }\n  }\n  \n  // Extract brand from device_type if device_brand not provided\n  const brand = diagnosis.device_brand \n    ? normalizeText(diagnosis.device_brand)\n    : diagnosis.device_type \n      ? extractBrand(diagnosis.device_type)\n      : ''\n  \n  // Check brand match (high priority) - check both expertise and services\n  if (brand) {\n    // Check expertise\n    const brandMatchExpertise = normalizedExpertise.some(exp => {\n      const expLower = normalizeText(exp)\n      return expLower.includes(brand) || brand.includes(expLower) ||\n        expLower.startsWith(brand) || brand.startsWith(expLower)\n    })\n    \n    // Check services\n    const brandMatchServices = normalizedServices.some(service => {\n      return service.fullText.includes(brand) || \n        service.name.includes(brand) ||\n        service.type.includes(brand)\n    })\n    \n    if (brandMatchExpertise || brandMatchServices) {\n      score += 3\n      matchedTerms.push(brand)\n    }\n  }\n  \n  // Check device type match (medium-high priority) - check both expertise and services\n  if (diagnosis.device_type) {\n    const deviceType = normalizeText(diagnosis.device_type)\n    \n    // Check expertise\n    const deviceMatchExpertise = normalizedExpertise.some(exp => {\n      const expLower = normalizeText(exp)\n      return expLower.includes(deviceType) || \n        deviceType.includes(expLower) ||\n        deviceType.startsWith(expLower) ||\n        expLower.startsWith(deviceType.split(' ')[0])\n    })\n    \n    // Check services\n    const deviceMatchServices = normalizedServices.some(service => {\n      return service.fullText.includes(deviceType) ||\n        service.name.includes(deviceType) ||\n        service.description.includes(deviceType)\n    })\n    \n    if (deviceMatchExpertise || deviceMatchServices) {\n      score += 2\n      matchedTerms.push(diagnosis.device_type)\n    }\n  }\n  \n  // Check repair component match (high priority) - check both expertise and services\n  if (diagnosis.repair_component) {\n    const componentVariations = [\n      ...getRepairComponentVariations(diagnosis.repair_component),\n      ...(diagnosis.repair_keywords || []).map(k => normalizeText(k))\n    ]\n    \n    // Check expertise\n    const componentMatchExpertise = normalizedExpertise.some(exp => {\n      const expLower = normalizeText(exp)\n      return componentVariations.some(variation => {\n        const variationNorm = normalizeText(variation)\n        return expLower.includes(variationNorm) || \n          variationNorm.includes(expLower) ||\n          expLower.startsWith(variationNorm) ||\n          variationNorm.startsWith(expLower) ||\n          expLower.split(/\\s+/).includes(variationNorm) ||\n          variationNorm.split(/\\s+/).includes(expLower)\n      })\n    })\n    \n    // Check services - this is very important for matching\n    const componentMatchServices = normalizedServices.some(service => {\n      return componentVariations.some(variation => {\n        const variationNorm = normalizeText(variation)\n        // Check service name, description, and type\n        return service.name.includes(variationNorm) ||\n          variationNorm.includes(service.name) ||\n          service.description.includes(variationNorm) ||\n          variationNorm.includes(service.description) ||\n          service.type.includes(variationNorm) ||\n          variationNorm.includes(service.type) ||\n          service.fullText.includes(variationNorm) ||\n          variationNorm.includes(service.fullText) ||\n          // Check word boundaries\n          service.name.split(/\\s+/).includes(variationNorm) ||\n          service.description.split(/\\s+/).includes(variationNorm) ||\n          service.type.split(/\\s+/).includes(variationNorm)\n      })\n    })\n    \n    if (componentMatchExpertise || componentMatchServices) {\n      score += 3\n      matchedTerms.push(diagnosis.repair_component)\n    }\n  }\n  \n  // Check repair keywords if provided - check both expertise and services\n  if (diagnosis.repair_keywords) {\n    diagnosis.repair_keywords.forEach(keyword => {\n      const keywordNorm = normalizeText(keyword)\n      \n      // Check expertise\n      const keywordMatchExpertise = normalizedExpertise.some(exp => {\n        const expLower = normalizeText(exp)\n        return expLower.includes(keywordNorm) || keywordNorm.includes(expLower)\n      })\n      \n      // Check services\n      const keywordMatchServices = normalizedServices.some(service => {\n        return service.fullText.includes(keywordNorm) ||\n          service.name.includes(keywordNorm) ||\n          service.description.includes(keywordNorm) ||\n          service.type.includes(keywordNorm)\n      })\n      \n      if (keywordMatchExpertise || keywordMatchServices) {\n        score += 1\n        matchedTerms.push(keyword)\n      }\n    })\n  }\n  \n  // Match if score >= 3 (either brand+component, or strong component match)\n  const matches = score >= 3\n  \n  return { matches, score, matchedTerms: [...new Set(matchedTerms)] }\n}\n\n/**\n * Sort shops by match relevance\n */\nexport function sortShopsByRelevance(\n  shops: any[],\n  diagnosis: DiagnosisMatch\n): any[] {\n  return shops\n    .map(shop => {\n      const services = (shop.shop_products || []).filter((p: any) => p.category === \"service\" && p.in_stock !== false)\n      return {\n        ...shop,\n        matchResult: shopMatchesDiagnosis(shop.expertise || [], diagnosis, services),\n      }\n    })\n    .sort((a, b) => {\n      // First sort by match score (higher is better)\n      if (b.matchResult.score !== a.matchResult.score) {\n        return b.matchResult.score - a.matchResult.score\n      }\n      // Then by rating (higher is better)\n      if (b.rating !== a.rating) {\n        return (b.rating || 0) - (a.rating || 0)\n      }\n      // Then by distance if available\n      if (a.distance !== undefined && b.distance !== undefined) {\n        return a.distance - b.distance\n      }\n      return 0\n    })\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 487, "column": 0}, "map": {"version":3,"sources":["file:///Users/ss/Downloads/ai-repair-diagnosis-saas-main/app/shops/page.tsx"],"sourcesContent":["import { createClient } from \"@/lib/supabase/server\"\nimport { ShopDirectory } from \"@/components/shop-directory\"\nimport type { Metadata } from \"next\"\nimport { shopMatchesDiagnosis, sortShopsByRelevance } from \"@/lib/utils/shop-matching\"\nimport { getShopsPageMetadata, getLocaleFromHeaders } from \"@/lib/i18n/metadata\"\nimport { headers } from \"next/headers\"\n\nexport async function generateMetadata(): Promise<Metadata> {\n  const headersList = await headers()\n  const locale = getLocaleFromHeaders(headersList)\n  return getShopsPageMetadata(locale)\n}\n\nexport default async function ShopsPage({\n  searchParams,\n}: {\n  searchParams: Promise<{ diagnosis?: string }>\n}) {\n  const params = await searchParams\n  const supabase = await createClient()\n  \n  // Enhanced structured data for shops page\n  const shopsStructuredData = {\n    \"@context\": \"https://schema.org\",\n    \"@type\": \"ItemList\",\n    name: \"Repair Shops Directory\",\n    description: \"Find trusted local repair shops for phone, laptop, and tablet repairs\",\n    url: `${baseUrl}/shops`,\n    numberOfItems: 0, // Will be updated dynamically\n    itemListElement: [] as any[]\n  }\n\n  // Fetch diagnosis if provided\n  let diagnosis = null\n  let repairComponent = null\n  \n  if (params.diagnosis) {\n    const { data: diagnosisData } = await supabase.from(\"diagnoses\").select(\"*\").eq(\"id\", params.diagnosis).single()\n    diagnosis = diagnosisData\n    \n    if (diagnosis?.ai_response?.repair_component) {\n      repairComponent = diagnosis.ai_response.repair_component.toLowerCase()\n    }\n  }\n\n  // Fetch all shops\n  const { data: shops, error } = await supabase\n    .from(\"repair_shops\")\n    .select(\"*\")\n\n  // Fetch all services/products for shops\n  const { data: allProducts } = await supabase\n    .from(\"shop_products\")\n    .select(\"*\")\n    .eq(\"category\", \"service\")\n\n  // Group products by shop_id\n  const productsByShop = new Map<string, any[]>()\n  if (allProducts) {\n    allProducts.forEach((product: any) => {\n      if (!productsByShop.has(product.shop_id)) {\n        productsByShop.set(product.shop_id, [])\n      }\n      productsByShop.get(product.shop_id)!.push(product)\n    })\n  }\n\n  // Attach products to shops\n  const shopsWithProducts = (shops || []).map(shop => ({\n    ...shop,\n    shop_products: productsByShop.get(shop.id) || []\n  }))\n\n  if (error) {\n    console.error(\"Error fetching shops:\", error)\n  }\n\n  let filteredShops = shopsWithProducts || []\n  \n  // Use smart matching if diagnosis is available\n  if (diagnosis?.ai_response) {\n    const diagnosisMatch = {\n      device_brand: diagnosis.ai_response.device_brand,\n      device_type: diagnosis.ai_response.device_type,\n      repair_component: diagnosis.ai_response.repair_component,\n      repair_keywords: diagnosis.ai_response.repair_keywords,\n    }\n    \n    // Filter shops that match the diagnosis (checking both expertise and services)\n    filteredShops = filteredShops.filter(shop => {\n      const services = (shop.shop_products || []).filter((p: any) => p.category === \"service\" && p.in_stock !== false)\n      const matchResult = shopMatchesDiagnosis(\n        shop.expertise || [], \n        diagnosisMatch,\n        services\n      )\n      return matchResult.matches\n    })\n    \n    // Sort by relevance (match score, then rating, then distance)\n    filteredShops = sortShopsByRelevance(filteredShops, diagnosisMatch)\n    \n    // If no matches found, fall back to broader matching\n    if (filteredShops.length === 0 && repairComponent) {\n      const allShops = shopsWithProducts || []\n      filteredShops = allShops.filter(shop => {\n        const expertise = (shop.expertise || []).map((e: string) => e.toLowerCase())\n        const services = (shop.shop_products || [])\n          .filter((p: any) => p.category === \"service\")\n          .map((p: any) => `${p.name} ${p.description || \"\"} ${p.type || \"\"}`.toLowerCase())\n        const component = repairComponent.toLowerCase()\n        \n        // Check expertise\n        const expertiseMatch = expertise.some((exp: string) => \n          exp.includes(component) || \n          component.includes(exp) ||\n          (diagnosisMatch.device_brand && exp.includes(diagnosisMatch.device_brand.toLowerCase()))\n        )\n        \n        // Check services\n        const serviceMatch = services.some((serviceText: string) =>\n          serviceText.includes(component) ||\n          component.includes(serviceText) ||\n          (diagnosisMatch.device_brand && serviceText.includes(diagnosisMatch.device_brand.toLowerCase()))\n        )\n        \n        return expertiseMatch || serviceMatch\n      })\n      \n      // Sort by rating\n      filteredShops.sort((a, b) => (b.rating || 0) - (a.rating || 0))\n    }\n  } else {\n    // No diagnosis - just sort by rating\n    filteredShops.sort((a, b) => (b.rating || 0) - (a.rating || 0))\n  }\n\n  // Update structured data with shop count\n  shopsStructuredData.numberOfItems = filteredShops.length\n  shopsStructuredData.itemListElement = filteredShops.slice(0, 10).map((shop, index) => ({\n    \"@type\": \"ListItem\",\n    position: index + 1,\n    item: {\n      \"@type\": \"LocalBusiness\",\n      name: shop.name,\n      url: `${baseUrl}/shops/${shop.id}`,\n      address: {\n        \"@type\": \"PostalAddress\",\n        streetAddress: shop.address\n      }\n    }\n  }))\n\n  return (\n    <>\n      <script\n        type=\"application/ld+json\"\n        dangerouslySetInnerHTML={{\n          __html: JSON.stringify(shopsStructuredData),\n        }}\n      />\n      <script\n        type=\"application/ld+json\"\n        dangerouslySetInnerHTML={{\n          __html: JSON.stringify({\n            \"@context\": \"https://schema.org\",\n            \"@type\": \"BreadcrumbList\",\n            itemListElement: [\n              {\n                \"@type\": \"ListItem\",\n                position: 1,\n                name: \"Home\",\n                item: baseUrl\n              },\n              {\n                \"@type\": \"ListItem\",\n                position: 2,\n                name: \"Repair Shops\",\n                item: `${baseUrl}/shops`\n              }\n            ]\n          }),\n        }}\n      />\n      <ShopDirectory shops={filteredShops} diagnosis={diagnosis} repairComponent={repairComponent} />\n    </>\n  )\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}